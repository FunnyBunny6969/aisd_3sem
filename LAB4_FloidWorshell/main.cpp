#include <iostream>   // подключаем библиотеку для ввода-вывода (cout, cin)
#include <vector>     // подключаем вектор — динамический массив
#include <iomanip>    // для красивого форматированного вывода таблиц

using namespace std;  // чтобы не писать std:: перед каждой командой

int main() {
    const int INF = 1000000; // задаём очень большое число — обозначает "бесконечность"

    // ----- Матрица исходных расстояний -----
    // dist[i][j] = вес ребра из вершины i в вершину j
    // Если ребра нет, ставим INF (бесконечность)
    vector<vector<int>> dist = {
        {0, 28, 21, 59, 12, 27},
        {7, 0, 24, INF, 21, 9},
        {9, 32, 0, 13, 11, INF},
        {8, INF, 5, 0, 16, INF},
        {14, 13, 15, 10, 0, 22},
        {15, 18, INF, INF, 6, 0}
    };

    // ----- Матрица последовательности вершин -----
    // P[i][j] хранит номер следующей вершины после i на кратчайшем пути к j
    // Если пути нет, ставим 0
    vector<vector<int>> P = {
        {0, 2, 3, 4, 5, 6},
        {1, 0, 3, 0, 5, 6},
        {1, 2, 0, 4, 5, 0},
        {1, 0, 3, 0, 5, 0},
        {1, 2, 3, 4, 0, 6},
        {1, 2, 0, 0, 5, 0}
    };

    int n = dist.size(); // определяем количество вершин (6)

    // ----- Основной алгоритм Флойда–Уоршелла -----
    // Три вложенных цикла проверяют все возможные промежуточные вершины k
    // и пытаются улучшить путь между каждой парой (i, j)
    for (int k = 0; k < n; ++k) {         // перебор промежуточной вершины k
        for (int i = 0; i < n; ++i) {     // перебор начальной вершины i
            for (int j = 0; j < n; ++j) { // перебор конечной вершины j

                // Проверяем, существуют ли пути i→k и k→j (не бесконечные)
                if (dist[i][k] < INF && dist[k][j] < INF &&

                    // Проверяем, короче ли путь i→k→j, чем существующий i→j
                    dist[i][j] > dist[i][k] + dist[k][j]) {

                    // Если нашли более короткий путь — обновляем его длину
                    dist[i][j] = dist[i][k] + dist[k][j];

                    // И обновляем первую вершину пути i→j: теперь это вершина,
                    // через которую начинается кратчайший маршрут i→k
                    P[i][j] = P[i][k];
                }
            }
        }
    }

    // ----- Вывод итоговой матрицы кратчайших расстояний -----
    cout << "Матрица кратчайших расстояний (после алгоритма):\n";
    for (int i = 0; i < n; ++i) {          // проходим по всем строкам
        for (int j = 0; j < n; ++j) {      // проходим по всем столбцам
            if (dist[i][j] == INF)         // если расстояние бесконечно —
                cout << setw(6) << "inf";  // выводим слово "inf"
            else
                cout << setw(6) << dist[i][j]; // иначе выводим само число
        }
        cout << endl; // перевод строки после каждой строки матрицы
    }

    // ----- Вывод итоговой матрицы последовательности вершин -----
    cout << "\nМатрица последовательности вершин (после алгоритма):\n";
    for (int i = 0; i < n; ++i) {
        for (int j = 0; j < n; ++j) {
		cout << setw(4) << P[i][j];
        }
        cout << endl;
    }

    // ----- Восстановление пути между вершинами -----
    // Лямбда-функция, которая по матрице P восстанавливает конкретный маршрут
    auto reconstructPath = [&](int u, int v) {
        if (P[u][v] == 0) { // если пути нет
            cout << "Пути " << u+1 << " → " << v+1 << " нет\n";
            return;
        }
        cout << "Путь " << u+1 << " → " << v+1 << ": ";
        cout << u+1; // выводим начальную вершину
        while (u + 1 != v + 1) { // пока не дошли до конечной
            u = P[u][v] - 1;    // переходим в следующую вершину
            cout << " → " << u + 1; // выводим её
        }
        cout << endl;
    };

    // ----- Пример восстановления одного пути -----
    cout << "\nПример восстановления пути:\n";
    reconstructPath(0, 3); // восстановим путь из 1-й вершины в 4-ю
    reconstructPath(1, 4); 

    return 0; // завершение программы
}
